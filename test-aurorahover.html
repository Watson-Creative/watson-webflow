<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic JS Aurora Effect</title>
    <style>
        :root {
            --redwood: #e93826;
            --sunset: #f58020;
            --larch: #fdb71a;
            --midnight: #022822;
            --forest: #0c4b41;
            --glacial: #00b795;
            --light-green: #92d0c3;
            --text: #040504;
            --text-light: #404040;
            --greywc: #82736f;
            --light-gray-2: #707070;
            --off-white: #f0edec;
            --white: #f4f2f1;
            --cloud: #f4f2f1;
        }
        
        body {
            margin: 0;
            padding: 40px;
            background: #000;
            color: var(--cloud);
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 10;
        }

        .hoverglow {
            position: relative;
            display: inline-block;
            margin: 20px;
            padding: 15px 25px;
            cursor: pointer;
            z-index: 10;
        }

        .hoverglow a {
            color: var(--glacial);
            text-decoration: none;
            font-weight: bold;
        }

        .hoverglow button {
            background: var(--glacial);
            border: none;
            color: var(--midnight);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }

        .hoverglow h1 {
            font-size: 2.5rem;
            margin: 20px 0;
            color: var(--cloud);
        }

        .hoverglow h2 {
            font-size: 1.8rem;
            margin: 15px 0;
            color: var(--light-green);
        }

        .hoverglow p {
            font-size: 1.1rem;
            line-height: 1.6;
            color: var(--cloud);
        }

        .aurora-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 5; /* Increased to ensure visibility */
            overflow: hidden;
            mix-blend-mode: screen; /* Add screen blend mode to container */
        }

        .demo-section {
            margin: 40px 0;
            padding: 20px;
            border: 1px solid var(--forest);
            border-radius: 10px;
            background: rgba(93, 93, 93, 0.2);
        }
    </style>
</head>
<body>
    <div class="aurora-container" id="auroraContainer"></div>
    
    <div class="container">
        <h1 class="hoverglow">Dynamic JS Aurora</h1>

        <div class="demo-section">
            <h2 class="hoverglow">Pure JavaScript Effect</h2>
            
            <p class="hoverglow">
                All aurora effects are now generated entirely through JavaScript, allowing for dynamic and customizable behavior.
            </p>
            
            <a href="#" class="hoverglow">Explore Our Work</a>
            
            <br><br>
            
            <button class="hoverglow">GET STARTED</button>
            
            <br><br>
            
            <span class="hoverglow" style="padding: 10px 20px; background: var(--forest); border-radius: 5px; color: var(--cloud);">
                Hover for Dynamic Glow
            </span>
            
            <br><br>
            
            <span class="hoverglow" style="padding: 10px 20px; background: var(--redwood); border-radius: 5px; color: var(--cloud);">
                Warm Dynamic Glow
            </span>
        </div>
    </div>

    <script>
        class GlowEffect {
            constructor() {
                this.container = document.getElementById('auroraContainer');
                this.activeGlows = new Map();
                this.frameId = null;
                this.easingFactor = 0.12;
                
                // Dynamic color palettes
                this.colorPalettes = {
                    warm: [
                        'rgba(233, 56, 38, 0.8)',   // redwood
                        'rgba(245, 128, 32, 0.7)',  // sunset
                        'rgba(253, 183, 26, 0.6)'   // larch
                    ],
                    cool: [
                        'rgba(0, 183, 149, 0.8)',   // glacial
                        'rgba(146, 208, 195, 0.7)', // light-green
                        'rgba(12, 75, 65, 0.6)'     // forest
                    ],
                    mixed: [
                        'rgba(233, 56, 38, 0.8)',   // redwood
                        'rgba(245, 128, 32, 0.7)',  // sunset
                        'rgba(253, 183, 26, 0.6)',   // larch
                        'rgba(0, 183, 149, 0.8)',   // glacial
                        'rgba(146, 208, 195, 0.7)', // light-green
                        'rgba(12, 75, 65, 0.6)'     // forest
                    ]
                };
                
                this.init();
            }

            init() {
                document.querySelectorAll('.hoverglow').forEach(element => {
                    element.addEventListener('mouseenter', (e) => this.startGlow(e));
                    element.addEventListener('mousemove', (e) => this.updateMousePosition(e));
                    element.addEventListener('mouseleave', (e) => this.endGlow(e.target));
                });
            }

            startGlow(event) {
                const element = event.target;
                
                if (this.activeGlows.has(element)) {
                    return;
                }
                
                const rect = element.getBoundingClientRect();
                const elementSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
                const glowSize = elementSize * 3; // Increased for better circle visibility
                
                // Create main wrapper
                const wrapper = document.createElement('div');
                wrapper.style.cssText = `
                    position: absolute;
                    opacity: 0;
                    will-change: transform, opacity;
                    pointer-events: none;
                    transition: opacity 0.3s ease-in;
                `;
                
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const mouseOffsetX = event.clientX - centerX;
                const mouseOffsetY = event.clientY - centerY;
                const mouseInfluence = 0.3;
                const initialX = centerX + (mouseOffsetX * mouseInfluence);
                const initialY = centerY + (mouseOffsetY * mouseInfluence);
                
                wrapper.style.left = `${initialX - glowSize/2}px`;
                wrapper.style.top = `${initialY - glowSize/2}px`;
                wrapper.style.width = `${glowSize}px`;
                wrapper.style.height = `${glowSize}px`;

                // Choose color palette based on element
                let palette = this.colorPalettes.mixed;
                if (element.textContent.toLowerCase().includes('warm')) {
                    palette = this.colorPalettes.warm;
                } else if (element.textContent.toLowerCase().includes('nature')) {
                    palette = this.colorPalettes.cool;
                }

                const glowData = {
                    element: element,
                    wrapper: wrapper,
                    orbs: [],
                    cores: [],
                    rect: rect,
                    glowSize: glowSize,
                    targetX: initialX,
                    targetY: initialY,
                    currentX: initialX,
                    currentY: initialY,
                    centerX: centerX,
                    centerY: centerY,
                    time: 0,
                    palette: palette,
                    active: true,
                    fadeTimeout: null,
                    mouseInfluence: mouseInfluence
                };

                // Create dynamic glow layers
                this.createGlowLayers(wrapper, glowData);

                this.container.appendChild(wrapper);
                this.activeGlows.set(element, glowData);

                requestAnimationFrame(() => {
                    wrapper.style.opacity = '1';
                });

                if (!this.frameId) {
                    this.animate();
                }
            }

            createGlowLayers(wrapper, glowData) {
                const layerCount = 6; // More layers for richer effect
                const baseSize = glowData.glowSize;
                
                // Create multiple distinct orb layers
                for (let i = 0; i < layerCount; i++) {
                    const layerSize = baseSize * (1 - i * 0.12); // Smaller size reduction for overlap
                    const orb = document.createElement('div');
                    
                    // Dynamic gradient based on palette
                    const color1 = glowData.palette[i % glowData.palette.length];
                    const color2 = glowData.palette[(i + 1) % glowData.palette.length];
                    const color3 = glowData.palette[(i + 2) % glowData.palette.length];
                    
                    // Vary blur amounts for visual separation
                    const blurAmount = i === 0 ? 40 : 15 + i * 8; // First layer more blurred, others less
                    const opacity = i === 0 ? 0.4 : 0.6 - i * 0.08; // Varying opacity
                    
                    orb.style.cssText = `
                        position: absolute;
                        width: ${layerSize}px;
                        height: ${layerSize}px;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        border-radius: 50%;
                        pointer-events: none;
                        will-change: transform, filter;
                        mix-blend-mode: screen;
                        filter: blur(${blurAmount}px);
                        opacity: ${opacity};
                        background: radial-gradient(circle, 
                            ${color1} 0%, 
                            ${color2} 30%, 
                            ${color3} 60%, 
                            transparent 100%);
                    `;
                    
                    // Add more varied animation properties
                    orb.dataset.animSpeed = 0.3 + Math.random() * 1.2;
                    orb.dataset.animPhase = Math.random() * Math.PI * 2;
                    orb.dataset.animAmplitude = 8 + Math.random() * 15;
                    orb.dataset.rotationSpeed = (Math.random() - 0.5) * 2; // Rotation direction
                    orb.dataset.baseBlur = blurAmount;
                    
                    wrapper.appendChild(orb);
                    glowData.orbs.push(orb);
                }

                // Create multiple core layers for depth
                const coreCount = 3;
                glowData.cores = [];
                
                for (let i = 0; i < coreCount; i++) {
                    const core = document.createElement('div');
                    const coreSize = baseSize * (0.2 - i * 0.05);
                    const coreBlur = 5 + i * 3;
                    
                    core.style.cssText = `
                        position: absolute;
                        width: ${coreSize}px;
                        height: ${coreSize}px;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        border-radius: 50%;
                        pointer-events: none;
                        mix-blend-mode: screen;
                        filter: blur(${coreBlur}px);
                        opacity: ${0.9 - i * 0.2};
                        background: radial-gradient(circle, 
                            rgba(255,255,255,${1 - i * 0.3}) 0%, 
                            ${glowData.palette[i % glowData.palette.length]} 30%, 
                            transparent 100%);
                    `;
                    
                    core.dataset.animSpeed = 2 + Math.random();
                    core.dataset.animPhase = Math.random() * Math.PI * 2;
                    
                    wrapper.appendChild(core);
                    glowData.cores.push(core);
                }
            }

            updateMousePosition(event) {
                const element = event.target;
                const glowData = this.activeGlows.get(element);
                if (!glowData || !glowData.active) return;

                glowData.rect = element.getBoundingClientRect();
                glowData.centerX = glowData.rect.left + glowData.rect.width / 2;
                glowData.centerY = glowData.rect.top + glowData.rect.height / 2;
                
                const mouseOffsetX = event.clientX - glowData.centerX;
                const mouseOffsetY = event.clientY - glowData.centerY;
                
                glowData.targetX = glowData.centerX + (mouseOffsetX * glowData.mouseInfluence);
                glowData.targetY = glowData.centerY + (mouseOffsetY * glowData.mouseInfluence);
            }

            animate() {
                let hasActiveGlows = false;
                
                this.activeGlows.forEach((glowData, element) => {
                    if (!glowData.active && !glowData.wrapper.parentNode) {
                        this.activeGlows.delete(element);
                        return;
                    }
                    
                    if (glowData.active) {
                        hasActiveGlows = true;
                    }

                    glowData.time += 0.016;
                    
                    // Smooth position interpolation
                    const deltaX = glowData.targetX - glowData.currentX;
                    const deltaY = glowData.targetY - glowData.currentY;
                    
                    glowData.currentX += deltaX * this.easingFactor;
                    glowData.currentY += deltaY * this.easingFactor;
                    
                    const wrapperX = glowData.currentX - glowData.glowSize/2;
                    const wrapperY = glowData.currentY - glowData.glowSize/2;
                    
                    glowData.wrapper.style.left = `${wrapperX}px`;
                    glowData.wrapper.style.top = `${wrapperY}px`;

                    // Dynamic color shifting
                    const hueRotate = Math.sin(glowData.time * 0.5) * 30;
                    glowData.wrapper.style.filter = `hue-rotate(${hueRotate}deg)`;

                    // Animate each orb independently with more visible movement
                    glowData.orbs.forEach((orb, index) => {
                        const speed = parseFloat(orb.dataset.animSpeed);
                        const phase = parseFloat(orb.dataset.animPhase);
                        const amplitude = parseFloat(orb.dataset.animAmplitude);
                        const rotationSpeed = parseFloat(orb.dataset.rotationSpeed);
                        const baseBlur = parseFloat(orb.dataset.baseBlur);
                        
                        const time = glowData.time * speed;
                        
                        // Create circular motion patterns
                        const orbitRadius = amplitude * (1 + Math.sin(time * 0.3) * 0.3);
                        const orbitAngle = time + phase;
                        const wobbleX = Math.cos(orbitAngle) * orbitRadius;
                        const wobbleY = Math.sin(orbitAngle * 0.8) * orbitRadius;
                        
                        // Add secondary movement
                        const secondaryX = Math.sin(time * 1.3 + phase) * amplitude * 0.5;
                        const secondaryY = Math.cos(time * 1.7 + phase) * amplitude * 0.5;
                        
                        // Dynamic scale and rotation
                        const scale = 1 + Math.sin(time * 0.3 + phase) * 0.15;
                        const rotation = time * rotationSpeed * 20;
                        
                        // Dynamic blur for breathing effect
                        const blurVariation = Math.sin(time * 0.5) * 5;
                        const currentBlur = Math.max(5, baseBlur + blurVariation);
                        
                        // Brightness pulsing
                        const brightness = 1 + Math.sin(time * 0.7 + phase) * 0.3;
                        
                        orb.style.transform = `
                            translate(-50%, -50%) 
                            translate(${wobbleX + secondaryX}px, ${wobbleY + secondaryY}px) 
                            scale(${scale}) 
                            rotate(${rotation}deg)
                        `;
                        orb.style.filter = `blur(${currentBlur}px) brightness(${brightness})`;
                    });

                    // Animate cores with distinct patterns
                    if (glowData.cores) {
                        glowData.cores.forEach((core, index) => {
                            const speed = parseFloat(core.dataset.animSpeed);
                            const phase = parseFloat(core.dataset.animPhase);
                            
                            const time = glowData.time * speed;
                            
                            // Cores move in tighter patterns
                            const coreX = Math.sin(time + phase) * 3;
                            const coreY = Math.cos(time * 1.3 + phase) * 3;
                            
                            const coreScale = 1 + Math.sin(time + phase) * 0.2;
                            const coreBrightness = 1.3 + Math.sin(time * 1.5 + phase) * 0.4;
                            const coreRotation = time * 30;
                            
                            core.style.transform = `
                                translate(-50%, -50%) 
                                translate(${coreX}px, ${coreY}px) 
                                scale(${coreScale})
                                rotate(${coreRotation}deg)
                            `;
                            core.style.filter = `blur(${5 + index * 3}px) brightness(${coreBrightness})`;
                        });
                    }
                });

                if (hasActiveGlows || this.activeGlows.size > 0) {
                    this.frameId = requestAnimationFrame(() => this.animate());
                } else {
                    this.frameId = null;
                }
            }

            endGlow(element) {
                const glowData = this.activeGlows.get(element);
                if (!glowData) return;

                if (glowData.fadeTimeout) {
                    clearTimeout(glowData.fadeTimeout);
                }

                glowData.active = false;
                glowData.wrapper.style.opacity = '0';
                glowData.wrapper.style.transition = 'opacity 0.4s ease-out';

                glowData.fadeTimeout = setTimeout(() => {
                    if (glowData.wrapper && glowData.wrapper.parentNode) {
                        glowData.wrapper.parentNode.removeChild(glowData.wrapper);
                    }
                    this.activeGlows.delete(element);
                    
                    if (this.activeGlows.size === 0 && this.frameId) {
                        cancelAnimationFrame(this.frameId);
                        this.frameId = null;
                    }
                }, 400);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GlowEffect();
        });
    </script>
</body>
</html>