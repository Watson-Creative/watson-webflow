<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic JS Aurora Effect</title>
    <style>
        :root {
            --redwood: #e93826;
            --sunset: #f58020;
            --larch: #fdb71a;
            --midnight: #022822;
            --forest: #0c4b41;
            --glacial: #00b795;
            --light-green: #92d0c3;
            --text: #040504;
            --text-light: #404040;
            --greywc: #82736f;
            --light-gray-2: #707070;
            --off-white: #f0edec;
            --white: #f4f2f1;
            --cloud: #f4f2f1;
        }
        
        body {
            margin: 0;
            padding: 40px;
            background: #000;
            color: var(--cloud);
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 10;
        }

        .hoverglow {
            position: relative;
            display: inline-block;
            margin: 20px;
            padding: 15px 25px;
            cursor: pointer;
            z-index: 10;
        }

        .hoverglow a {
            color: var(--glacial);
            text-decoration: none;
            font-weight: bold;
        }

        .hoverglow button {
            background: var(--glacial);
            border: none;
            color: var(--midnight);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }

        .hoverglow h1 {
            font-size: 2.5rem;
            margin: 20px 0;
            color: var(--cloud);
        }

        .hoverglow h2 {
            font-size: 1.8rem;
            margin: 15px 0;
            color: var(--light-green);
        }

        .hoverglow p {
            font-size: 1.1rem;
            line-height: 1.6;
            color: var(--cloud);
        }

        .aurora-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 5; /* Increased to ensure visibility */
            overflow: hidden;
        }

        .demo-section {
            margin: 40px 0;
            padding: 20px;
            border: 1px solid var(--forest);
            border-radius: 10px;
            background: rgba(93, 93, 93, 0.2);
        }
    </style>
</head>
<body>
    <div class="aurora-container" id="auroraContainer"></div>
    
    <div class="container">
        <h1 class="hoverglow">Dynamic JS Aurora</h1>

        <div class="demo-section">
            <h2 class="hoverglow">Pure JavaScript Effect</h2>
            
            <p class="hoverglow">
                All aurora effects are now generated entirely through JavaScript, allowing for dynamic and customizable behavior.
            </p>
            
            <a href="#" class="hoverglow">Explore Our Work</a>
            
            <br><br>
            
            <button class="hoverglow">GET STARTED</button>
            
            <br><br>
            
            <span class="hoverglow" style="padding: 10px 20px; background: var(--forest); border-radius: 5px; color: var(--cloud);">
                Hover for Dynamic Glow
            </span>
            
            <br><br>
            
            <span class="hoverglow" style="padding: 10px 20px; background: var(--redwood); border-radius: 5px; color: var(--cloud);">
                Warm Dynamic Glow
            </span>
        </div>
    </div>

    <script>
        class GlowEffect {
            constructor() {
                this.container = document.getElementById('auroraContainer');
                this.activeGlows = new Map();
                this.frameId = null;
                this.easingFactor = 0.12;
                
                // Dynamic color palettes
                this.colorPalettes = {
                    warm: [
                        'rgba(233, 56, 38, 0.8)',   // redwood
                        'rgba(245, 128, 32, 0.7)',  // sunset
                        'rgba(253, 183, 26, 0.6)'   // larch
                    ],
                    cool: [
                        'rgba(0, 183, 149, 0.8)',   // glacial
                        'rgba(146, 208, 195, 0.7)', // light-green
                        'rgba(12, 75, 65, 0.6)'     // forest
                    ],
                    mixed: [
                        'rgba(233, 56, 38, 0.8)',   // redwood
                        'rgba(245, 128, 32, 0.7)',  // sunset
                        'rgba(253, 183, 26, 0.6)',   // larch
                        'rgba(0, 183, 149, 0.8)',   // glacial
                        'rgba(146, 208, 195, 0.7)', // light-green
                        'rgba(12, 75, 65, 0.6)'     // forest
                    ]
                };
                
                this.init();
            }

            init() {
                document.querySelectorAll('.hoverglow').forEach(element => {
                    element.addEventListener('mouseenter', (e) => this.startGlow(e));
                    element.addEventListener('mousemove', (e) => this.updateMousePosition(e));
                    element.addEventListener('mouseleave', (e) => this.endGlow(e.target));
                });
            }

            startGlow(event) {
                const element = event.target;
                
                if (this.activeGlows.has(element)) {
                    return;
                }
                
                const rect = element.getBoundingClientRect();
                const elementSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
                const glowSize = elementSize * 3; // Increased for better circle visibility
                
                // Create main wrapper
                const wrapper = document.createElement('div');
                wrapper.style.cssText = `
                    position: absolute;
                    opacity: 0;
                    will-change: transform, opacity, filter;
                    pointer-events: none;
                    transition: opacity 0.3s ease-in;
                    mix-blend-mode: screen;
                `;
                
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const mouseOffsetX = event.clientX - centerX;
                const mouseOffsetY = event.clientY - centerY;
                const mouseInfluence = 0.3;
                const initialX = centerX + (mouseOffsetX * mouseInfluence);
                const initialY = centerY + (mouseOffsetY * mouseInfluence);
                
                wrapper.style.left = `${initialX - glowSize/2}px`;
                wrapper.style.top = `${initialY - glowSize/2}px`;
                wrapper.style.width = `${glowSize}px`;
                wrapper.style.height = `${glowSize}px`;

                // Choose color palette based on element
                let palette = this.colorPalettes.mixed;
                if (element.textContent.toLowerCase().includes('warm')) {
                    palette = this.colorPalettes.warm;
                } else if (element.textContent.toLowerCase().includes('nature')) {
                    palette = this.colorPalettes.cool;
                }

                const glowData = {
                    element: element,
                    wrapper: wrapper,
                    orbs: [],
                    cores: [],
                    coreWrapper: null,
                    rect: rect,
                    glowSize: glowSize,
                    targetX: initialX,
                    targetY: initialY,
                    currentX: initialX,
                    currentY: initialY,
                    centerX: centerX,
                    centerY: centerY,
                    time: 0,
                    palette: palette,
                    active: true,
                    fadeTimeout: null,
                    mouseInfluence: mouseInfluence
                };

                // Create dynamic glow layers
                this.createGlowLayers(wrapper, glowData);

                this.container.appendChild(wrapper);
                this.activeGlows.set(element, glowData);

                requestAnimationFrame(() => {
                    wrapper.style.opacity = '1';
                });

                if (!this.frameId) {
                    this.animate();
                }
            }

            createGlowLayers(wrapper, glowData) {
                // Create 4-8 random circles for more variation
                const circleCount = 4 + Math.floor(Math.random() * 5);
                const baseSize = glowData.glowSize;
                
                for (let i = 0; i < circleCount; i++) {
                    const circle = document.createElement('div');
                    
                    // Random size variation (0.2x to 0.8x of base size)
                    const sizeMultiplier = 0.2 + Math.random() * 0.6;
                    const circleSize = baseSize * sizeMultiplier;
                    
                    // Random color from palette
                    const color = glowData.palette[Math.floor(Math.random() * glowData.palette.length)];
                    
                    // Random position offsets for uneven distribution
                    const offsetRange = baseSize * 0.5;
                    const randomX = (Math.random() - 0.5) * offsetRange;
                    const randomY = (Math.random() - 0.5) * offsetRange;
                    
                    circle.style.cssText = `
                        position: absolute;
                        width: ${circleSize}px;
                        height: ${circleSize}px;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%) translate(${randomX}px, ${randomY}px);
                        border-radius: 50%;
                        background: ${color};
                        pointer-events: none;
                        will-change: transform;
                        opacity: ${0.7 + Math.random() * 0.3};
                    `;
                    
                    // Store animation data
                    circle.dataset.initialX = randomX;
                    circle.dataset.initialY = randomY;
                    circle.dataset.driftSpeed = 0.2 + Math.random() * 0.5;
                    circle.dataset.driftAmplitude = 10 + Math.random() * 30;
                    circle.dataset.phase = Math.random() * Math.PI * 2;
                    circle.dataset.rotationSpeed = (Math.random() - 0.5) * 0.5;
                    
                    glowData.orbs.push(circle);
                }
                
                // Apply blur to the entire wrapper for soft glow effect
                wrapper.style.filter = 'blur(50px)';
                
                // Add all circles to wrapper
                glowData.orbs.forEach(orb => wrapper.appendChild(orb));
                
                // Create a separate sharp core layer (optional, not blurred)
                const coreWrapper = document.createElement('div');
                coreWrapper.style.cssText = `
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                `;
                
                // Add 1-2 bright cores
                const coreCount = 1 + Math.floor(Math.random() * 2);
                glowData.cores = [];
                
                for (let i = 0; i < coreCount; i++) {
                    const core = document.createElement('div');
                    const coreSize = baseSize * (0.1 + Math.random() * 0.1);
                    const coreX = (Math.random() - 0.5) * baseSize * 0.3;
                    const coreY = (Math.random() - 0.5) * baseSize * 0.3;
                    
                    core.style.cssText = `
                        position: absolute;
                        width: ${coreSize}px;
                        height: ${coreSize}px;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%) translate(${coreX}px, ${coreY}px);
                        border-radius: 50%;
                        background: radial-gradient(circle, 
                            rgba(255,255,255,0.9) 0%, 
                            ${glowData.palette[0]} 50%, 
                            transparent 100%);
                        filter: blur(8px);
                        pointer-events: none;
                        opacity: 0.8;
                    `;
                    
                    core.dataset.initialX = coreX;
                    core.dataset.initialY = coreY;
                    core.dataset.animSpeed = 2 + Math.random();
                    core.dataset.phase = Math.random() * Math.PI * 2;
                    
                    coreWrapper.appendChild(core);
                    glowData.cores.push(core);
                }
                
                wrapper.appendChild(coreWrapper);
                glowData.coreWrapper = coreWrapper;
            }

            updateMousePosition(event) {
                const element = event.target;
                const glowData = this.activeGlows.get(element);
                if (!glowData || !glowData.active) return;

                glowData.rect = element.getBoundingClientRect();
                glowData.centerX = glowData.rect.left + glowData.rect.width / 2;
                glowData.centerY = glowData.rect.top + glowData.rect.height / 2;
                
                const mouseOffsetX = event.clientX - glowData.centerX;
                const mouseOffsetY = event.clientY - glowData.centerY;
                
                glowData.targetX = glowData.centerX + (mouseOffsetX * glowData.mouseInfluence);
                glowData.targetY = glowData.centerY + (mouseOffsetY * glowData.mouseInfluence);
            }

            animate() {
                let hasActiveGlows = false;
                
                this.activeGlows.forEach((glowData, element) => {
                    if (!glowData.active && !glowData.wrapper.parentNode) {
                        this.activeGlows.delete(element);
                        return;
                    }
                    
                    if (glowData.active) {
                        hasActiveGlows = true;
                    }

                    glowData.time += 0.016;
                    
                    // Smooth position interpolation
                    const deltaX = glowData.targetX - glowData.currentX;
                    const deltaY = glowData.targetY - glowData.currentY;
                    
                    glowData.currentX += deltaX * this.easingFactor;
                    glowData.currentY += deltaY * this.easingFactor;
                    
                    const wrapperX = glowData.currentX - glowData.glowSize/2;
                    const wrapperY = glowData.currentY - glowData.glowSize/2;
                    
                    glowData.wrapper.style.left = `${wrapperX}px`;
                    glowData.wrapper.style.top = `${wrapperY}px`;

                    // Dynamic color shifting - subtle
                    const hueRotate = Math.sin(glowData.time * 0.3) * 20;
                    glowData.wrapper.style.filter = `blur(50px) hue-rotate(${hueRotate}deg)`;

                    // Animate each circle with gentle drift
                    glowData.orbs.forEach((orb) => {
                        const initialX = parseFloat(orb.dataset.initialX);
                        const initialY = parseFloat(orb.dataset.initialY);
                        const driftSpeed = parseFloat(orb.dataset.driftSpeed);
                        const driftAmplitude = parseFloat(orb.dataset.driftAmplitude);
                        const phase = parseFloat(orb.dataset.phase);
                        const rotationSpeed = parseFloat(orb.dataset.rotationSpeed);
                        
                        const time = glowData.time * driftSpeed;
                        
                        // Gentle drift motion
                        const driftX = Math.sin(time + phase) * driftAmplitude;
                        const driftY = Math.cos(time * 0.8 + phase) * driftAmplitude * 0.7;
                        
                        // Slight rotation
                        const rotation = time * rotationSpeed * 30;
                        
                        // Gentle scale breathing
                        const scale = 1 + Math.sin(time * 0.5 + phase) * 0.1;
                        
                        orb.style.transform = `
                            translate(-50%, -50%) 
                            translate(${initialX + driftX}px, ${initialY + driftY}px) 
                            scale(${scale})
                            rotate(${rotation}deg)
                        `;
                    });

                    // Animate cores with subtle pulsing
                    if (glowData.cores && glowData.coreWrapper) {
                        glowData.cores.forEach((core) => {
                            const initialX = parseFloat(core.dataset.initialX);
                            const initialY = parseFloat(core.dataset.initialY);
                            const speed = parseFloat(core.dataset.animSpeed);
                            const phase = parseFloat(core.dataset.phase);
                            
                            const time = glowData.time * speed;
                            
                            // Very subtle movement
                            const coreX = initialX + Math.sin(time + phase) * 5;
                            const coreY = initialY + Math.cos(time * 0.7 + phase) * 5;
                            
                            const coreScale = 1 + Math.sin(time + phase) * 0.15;
                            const coreBrightness = 0.8 + Math.sin(time * 1.5 + phase) * 0.2;
                            
                            core.style.transform = `
                                translate(-50%, -50%) 
                                translate(${coreX}px, ${coreY}px) 
                                scale(${coreScale})
                            `;
                            core.style.opacity = coreBrightness;
                        });
                    }
                });

                if (hasActiveGlows || this.activeGlows.size > 0) {
                    this.frameId = requestAnimationFrame(() => this.animate());
                } else {
                    this.frameId = null;
                }
            }

            endGlow(element) {
                const glowData = this.activeGlows.get(element);
                if (!glowData) return;

                if (glowData.fadeTimeout) {
                    clearTimeout(glowData.fadeTimeout);
                }

                glowData.active = false;
                glowData.wrapper.style.opacity = '0';
                glowData.wrapper.style.transition = 'opacity 0.4s ease-out';

                glowData.fadeTimeout = setTimeout(() => {
                    if (glowData.wrapper && glowData.wrapper.parentNode) {
                        glowData.wrapper.parentNode.removeChild(glowData.wrapper);
                    }
                    this.activeGlows.delete(element);
                    
                    if (this.activeGlows.size === 0 && this.frameId) {
                        cancelAnimationFrame(this.frameId);
                        this.frameId = null;
                    }
                }, 400);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GlowEffect();
        });
    </script>
</body>
</html>