<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic JS Aurora Effect</title>
    <style>
        :root {
            --redwood: #e93826;
            --sunset: #f58020;
            --larch: #fdb71a;
            --midnight: #022822;
            --forest: #0c4b41;
            --glacial: #00b795;
            --light-green: #92d0c3;
            --text: #040504;
            --text-light: #404040;
            --greywc: #82736f;
            --light-gray-2: #707070;
            --off-white: #f0edec;
            --white: #f4f2f1;
            --cloud: #f4f2f1;
        }
        
        body {
            margin: 0;
            padding: 40px;
            background: #000;
            color: var(--cloud);
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 10;
        }

        .hoverglow {
            position: relative;
            display: inline-block;
            margin: 20px;
            padding: 15px 25px;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        /* Ensure interactive elements maintain proper z-index */
        .hoverglow * {
            position: relative;
            z-index: 1;
        }

        .hoverglow a {
            color: var(--glacial);
            text-decoration: none;
            font-weight: bold;
        }

        .hoverglow button {
            background: var(--glacial);
            border: none;
            color: var(--midnight);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }

        .hoverglow h1 {
            font-size: 2.5rem;
            margin: 20px 0;
            color: var(--cloud);
        }

        .hoverglow h2 {
            font-size: 1.8rem;
            margin: 15px 0;
            color: var(--light-green);
        }

        .hoverglow p {
            font-size: 1.1rem;
            line-height: 1.6;
            color: var(--cloud);
        }

        .aurora-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 5; /* Increased to ensure visibility */
            overflow: hidden;
        }

        .demo-section {
            margin: 40px 0;
            padding: 20px;
            border: 1px solid var(--forest);
            border-radius: 10px;
            background: rgba(93, 93, 93, 0.2);
        }
    </style>
</head>
<body>
    <div class="aurora-container" id="auroraContainer"></div>
    
    <div class="container">
        <h1 class="hoverglow">Dynamic JS Aurora</h1>

        <div class="demo-section">
            <h2 class="hoverglow">Pure JavaScript Effect</h2>
            
            <p class="hoverglow">
                All aurora effects are now generated entirely through JavaScript, allowing for dynamic and customizable behavior.
            </p>
            
            <a href="#" class="hoverglow">Explore Our Work</a>
            
            <br><br>
            
            <button class="hoverglow">GET STARTED</button>
            
            <br><br>
            
            <span class="hoverglow" style="padding: 10px 20px; background: var(--forest); border-radius: 5px; color: var(--cloud);">
                Hover for Dynamic Glow
            </span>
            
            <br><br>
            
            <span class="hoverglow" style="padding: 10px 20px; background: var(--redwood); border-radius: 5px; color: var(--cloud);">
                Warm Dynamic Glow
            </span>
        </div>
    </div>

    <script>
        class GlowEffect {
            constructor() {
                this.container = document.getElementById('auroraContainer');
                this.activeGlows = new Map();
                this.frameId = null;
                this.easingFactor = 0.12;
                
                // Dynamic color palettes
                this.colorPalettes = {
                    warm: [
                        'rgba(233, 56, 38, 0.8)',   // redwood
                        'rgba(245, 128, 32, 0.7)',  // sunset
                        'rgba(253, 183, 26, 0.6)'   // larch
                    ],
                    cool: [
                        'rgba(0, 183, 149, 0.8)',   // glacial
                        'rgba(146, 208, 195, 0.7)', // light-green
                        'rgba(12, 75, 65, 0.6)'     // forest
                    ],
                    mixed: [
                        'rgba(233, 56, 38, 0.8)',   // redwood
                        'rgba(245, 128, 32, 0.7)',  // sunset
                        'rgba(253, 183, 26, 0.6)',   // larch
                        'rgba(0, 183, 149, 0.8)',   // glacial
                        'rgba(146, 208, 195, 0.7)', // light-green
                        'rgba(12, 75, 65, 0.6)'     // forest
                    ]
                };
                
                this.init();
            }

            init() {
                console.log('GlowEffect initialized');
                
                // Use event delegation for better handling of all hoverglow elements
                document.addEventListener('mouseenter', (e) => {
                    // Check if the target or any parent has hoverglow class
                    const hoverElement = e.target.closest('.hoverglow');
                    if (hoverElement && !this.activeGlows.has(hoverElement)) {
                        console.log('Mouse enter on:', hoverElement);
                        // Create a new event with the hoverglow element as target
                        this.handleMouseEnter(e, hoverElement);
                    }
                }, true);
                
                document.addEventListener('mousemove', (e) => {
                    const hoverElement = e.target.closest('.hoverglow');
                    if (hoverElement && this.activeGlows.has(hoverElement)) {
                        this.handleMouseMove(e, hoverElement);
                    }
                }, true);
                
                document.addEventListener('mouseleave', (e) => {
                    const hoverElement = e.target.closest('.hoverglow');
                    if (hoverElement) {
                        // Check if we're actually leaving the hoverglow element
                        const relatedTarget = e.relatedTarget;
                        if (!relatedTarget || !hoverElement.contains(relatedTarget)) {
                            this.endGlow(hoverElement);
                        }
                    }
                }, true);
            }
            
            handleMouseEnter(event, element) {
                // Start glow with the original event but the correct element
                const e = {
                    target: element,
                    clientX: event.clientX,
                    clientY: event.clientY
                };
                this.startGlow(e);
            }
            
            handleMouseMove(event, element) {
                // Update position with the original event but the correct element
                const e = {
                    target: element,
                    clientX: event.clientX,
                    clientY: event.clientY
                };
                this.updateMousePosition(e);
            }

            startGlow(event) {
                try {
                    const element = event.target;
                    
                    // Prevent duplicate glows for the same element
                    if (this.activeGlows.has(element)) {
                        return;
                    }
                    
                    console.log('Starting glow for:', element);
                    
                    const rect = element.getBoundingClientRect();
                    const elementSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
                    const glowSize = elementSize * 3; // Increased for better circle visibility
                
                    // Create main wrapper
                    const wrapper = document.createElement('div');
                    wrapper.style.cssText = `
                        position: absolute;
                        opacity: 0;
                        will-change: transform, opacity, filter;
                        pointer-events: none;
                        transition: opacity 0.3s ease-in;
                        mix-blend-mode: screen;
                    `;
                    
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const mouseOffsetX = event.clientX - centerX;
                    const mouseOffsetY = event.clientY - centerY;
                    const mouseInfluence = 0.3;
                    const initialX = centerX + (mouseOffsetX * mouseInfluence);
                    const initialY = centerY + (mouseOffsetY * mouseInfluence);
                    
                    wrapper.style.left = `${initialX - glowSize/2}px`;
                    wrapper.style.top = `${initialY - glowSize/2}px`;
                    wrapper.style.width = `${glowSize}px`;
                    wrapper.style.height = `${glowSize}px`;

                    // Choose color palette based on element
                    let palette = this.colorPalettes.mixed;
                    if (element.textContent.toLowerCase().includes('warm')) {
                        palette = this.colorPalettes.warm;
                    } else if (element.textContent.toLowerCase().includes('nature')) {
                        palette = this.colorPalettes.cool;
                    }

                    const glowData = {
                        element: element,
                        wrapper: wrapper,
                        orbs: [],
                        cores: [],
                        coreWrapper: null,
                        rect: rect,
                        glowSize: glowSize,
                        targetX: initialX,
                        targetY: initialY,
                        currentX: initialX,
                        currentY: initialY,
                        centerX: centerX,
                        centerY: centerY,
                        time: 0,
                        palette: palette,
                        active: true,
                        fadeTimeout: null,
                        mouseInfluence: mouseInfluence
                    };

                    // Create dynamic glow layers
                    this.createGlowLayers(wrapper, glowData);

                    this.container.appendChild(wrapper);
                    this.activeGlows.set(element, glowData);

                    // Smooth fade in
                    requestAnimationFrame(() => {
                        wrapper.style.opacity = '1';
                    });

                    // Start animation loop if not already running
                    if (!this.frameId) {
                        this.animate();
                    }
                } catch (error) {
                    console.error('Error starting glow:', error);
                }
            }

            createGlowLayers(wrapper, glowData) {
                // Create 4-8 random circles for more variation
                const circleCount = 4 + Math.floor(Math.random() * 5);
                const baseSize = glowData.glowSize;
                
                for (let i = 0; i < circleCount; i++) {
                    const circle = document.createElement('div');
                    
                    // Random size variation (0.2x to 0.8x of base size)
                    const sizeMultiplier = 0.2 + Math.random() * 0.6;
                    const circleSize = baseSize * sizeMultiplier;
                    
                    // Random color from palette
                    const color = glowData.palette[Math.floor(Math.random() * glowData.palette.length)];
                    
                    // Random position offsets for uneven distribution
                    const offsetRange = baseSize * 0.5;
                    const randomX = (Math.random() - 0.5) * offsetRange;
                    const randomY = (Math.random() - 0.5) * offsetRange;
                    
                    circle.style.cssText = `
                        position: absolute;
                        width: ${circleSize}px;
                        height: ${circleSize}px;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%) translate(${randomX}px, ${randomY}px);
                        border-radius: 50%;
                        background: ${color};
                        pointer-events: none;
                        will-change: transform, border-radius;
                        opacity: ${0.7 + Math.random() * 0.3};
                        transition: all 0.3s ease;
                    `;
                    
                    // Store animation data
                    circle.dataset.initialX = randomX.toString();
                    circle.dataset.initialY = randomY.toString();
                    circle.dataset.currentX = randomX.toString();
                    circle.dataset.currentY = randomY.toString();
                    circle.dataset.targetX = randomX.toString();
                    circle.dataset.targetY = randomY.toString();
                    circle.dataset.size = circleSize.toString();
                    circle.dataset.driftSpeed = (0.1 + Math.random() * 0.3).toString();
                    circle.dataset.morphSpeed = (0.5 + Math.random() * 1).toString();
                    circle.dataset.phase = (Math.random() * Math.PI * 2).toString();
                    circle.dataset.rotationSpeed = ((Math.random() - 0.5) * 0.3).toString();
                    circle.dataset.lastPositionChange = '0';
                    circle.dataset.positionChangeInterval = (2 + Math.random() * 3).toString(); // Change position every 2-5 seconds
                    
                    glowData.orbs.push(circle);
                }
                
                // Apply blur to the entire wrapper for soft glow effect
                wrapper.style.filter = 'blur(50px)';
                
                // Add all circles to wrapper
                glowData.orbs.forEach(orb => wrapper.appendChild(orb));
                
                // Create a separate sharp core layer (optional, not blurred)
                const coreWrapper = document.createElement('div');
                coreWrapper.style.cssText = `
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                `;
                
                // Add 1-2 bright cores
                const coreCount = 1 + Math.floor(Math.random() * 2);
                glowData.cores = [];
                
                for (let i = 0; i < coreCount; i++) {
                    const core = document.createElement('div');
                    const coreSize = baseSize * (0.1 + Math.random() * 0.1);
                    const coreX = (Math.random() - 0.5) * baseSize * 0.3;
                    const coreY = (Math.random() - 0.5) * baseSize * 0.3;
                    
                    core.style.cssText = `
                        position: absolute;
                        width: ${coreSize}px;
                        height: ${coreSize}px;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%) translate(${coreX}px, ${coreY}px);
                        border-radius: 50%;
                        background: radial-gradient(circle, 
                            rgba(255,255,255,0.9) 0%, 
                            ${glowData.palette[0]} 50%, 
                            transparent 100%);
                        filter: blur(8px);
                        pointer-events: none;
                        opacity: 0.8;
                        transition: all 0.5s ease;
                    `;
                    
                    core.dataset.initialX = coreX.toString();
                    core.dataset.initialY = coreY.toString();
                    core.dataset.currentX = coreX.toString();
                    core.dataset.currentY = coreY.toString();
                    core.dataset.targetX = coreX.toString();
                    core.dataset.targetY = coreY.toString();
                    core.dataset.animSpeed = (2 + Math.random()).toString();
                    core.dataset.phase = (Math.random() * Math.PI * 2).toString();
                    core.dataset.lastPositionChange = '0';
                    
                    coreWrapper.appendChild(core);
                    glowData.cores.push(core);
                }
                
                wrapper.appendChild(coreWrapper);
                glowData.coreWrapper = coreWrapper;
            }

            updateMousePosition(event) {
                const element = event.target;
                const glowData = this.activeGlows.get(element);
                if (!glowData || !glowData.active) return;

                glowData.rect = element.getBoundingClientRect();
                glowData.centerX = glowData.rect.left + glowData.rect.width / 2;
                glowData.centerY = glowData.rect.top + glowData.rect.height / 2;
                
                const mouseOffsetX = event.clientX - glowData.centerX;
                const mouseOffsetY = event.clientY - glowData.centerY;
                
                glowData.targetX = glowData.centerX + (mouseOffsetX * glowData.mouseInfluence);
                glowData.targetY = glowData.centerY + (mouseOffsetY * glowData.mouseInfluence);
            }

            animate() {
                let hasActiveGlows = false;
                
                this.activeGlows.forEach((glowData, element) => {
                    if (!glowData.active && !glowData.wrapper.parentNode) {
                        this.activeGlows.delete(element);
                        return;
                    }
                    
                    if (glowData.active) {
                        hasActiveGlows = true;
                    }

                    glowData.time += 0.016;
                    
                    // Smooth position interpolation
                    const deltaX = glowData.targetX - glowData.currentX;
                    const deltaY = glowData.targetY - glowData.currentY;
                    
                    glowData.currentX += deltaX * this.easingFactor;
                    glowData.currentY += deltaY * this.easingFactor;
                    
                    const wrapperX = glowData.currentX - glowData.glowSize/2;
                    const wrapperY = glowData.currentY - glowData.glowSize/2;
                    
                    glowData.wrapper.style.left = `${wrapperX}px`;
                    glowData.wrapper.style.top = `${wrapperY}px`;

                    // Dynamic color shifting - subtle
                    const hueRotate = Math.sin(glowData.time * 0.3) * 20;
                    glowData.wrapper.style.filter = `blur(50px) hue-rotate(${hueRotate}deg)`;

                    // Animate each circle with gentle drift and morphing
                    glowData.orbs.forEach((orb) => {
                        const currentX = parseFloat(orb.dataset.currentX) || 0;
                        const currentY = parseFloat(orb.dataset.currentY) || 0;
                        const targetX = parseFloat(orb.dataset.targetX) || 0;
                        const targetY = parseFloat(orb.dataset.targetY) || 0;
                        const size = parseFloat(orb.dataset.size) || 100;
                        const driftSpeed = parseFloat(orb.dataset.driftSpeed) || 0.2;
                        const morphSpeed = parseFloat(orb.dataset.morphSpeed) || 0.7;
                        const phase = parseFloat(orb.dataset.phase) || 0;
                        const rotationSpeed = parseFloat(orb.dataset.rotationSpeed) || 0;
                        const lastPositionChange = parseFloat(orb.dataset.lastPositionChange) || 0;
                        const positionChangeInterval = parseFloat(orb.dataset.positionChangeInterval) || 3;
                        
                        // Check if it's time to change position
                        if (glowData.time - lastPositionChange > positionChangeInterval) {
                            // Generate new target position
                            const offsetRange = glowData.glowSize * 0.4;
                            orb.dataset.targetX = ((Math.random() - 0.5) * offsetRange).toString();
                            orb.dataset.targetY = ((Math.random() - 0.5) * offsetRange).toString();
                            orb.dataset.lastPositionChange = glowData.time.toString();
                        }
                        
                        // Smooth interpolation towards target position
                        const newX = currentX + (targetX - currentX) * 0.02;
                        const newY = currentY + (targetY - currentY) * 0.02;
                        orb.dataset.currentX = newX.toString();
                        orb.dataset.currentY = newY.toString();
                        
                        const time = glowData.time * driftSpeed;
                        const morphTime = glowData.time * morphSpeed;
                        
                        // Shape morphing - change border radius
                        const radiusX = 50 + Math.sin(morphTime + phase) * 20;
                        const radiusY = 50 + Math.cos(morphTime * 0.7 + phase) * 20;
                        
                        // Gentle drift on top of position changes
                        const driftX = Math.sin(time + phase) * 5;
                        const driftY = Math.cos(time * 0.8 + phase) * 5;
                        
                        // Slight rotation
                        const rotation = time * rotationSpeed * 30;
                        
                        // Gentle scale breathing
                        const scaleX = 1 + Math.sin(time * 0.5 + phase) * 0.1;
                        const scaleY = 1 + Math.cos(time * 0.5 + phase * 1.3) * 0.1;
                        
                        orb.style.transform = `
                            translate(-50%, -50%) 
                            translate(${newX + driftX}px, ${newY + driftY}px) 
                            scale(${scaleX}, ${scaleY})
                            rotate(${rotation}deg)
                        `;
                        orb.style.borderRadius = `${radiusX}% ${radiusY}%`;
                    });

                    // Animate cores with subtle pulsing and position changes
                    if (glowData.cores && glowData.coreWrapper) {
                        glowData.cores.forEach((core) => {
                            const currentX = parseFloat(core.dataset.currentX) || 0;
                            const currentY = parseFloat(core.dataset.currentY) || 0;
                            const targetX = parseFloat(core.dataset.targetX) || 0;
                            const targetY = parseFloat(core.dataset.targetY) || 0;
                            const speed = parseFloat(core.dataset.animSpeed) || 2;
                            const phase = parseFloat(core.dataset.phase) || 0;
                            const lastPositionChange = parseFloat(core.dataset.lastPositionChange) || 0;
                            
                            // Change position every 3-5 seconds
                            if (glowData.time - lastPositionChange > 3 + Math.random() * 2) {
                                const range = glowData.glowSize * 0.2;
                                core.dataset.targetX = ((Math.random() - 0.5) * range).toString();
                                core.dataset.targetY = ((Math.random() - 0.5) * range).toString();
                                core.dataset.lastPositionChange = glowData.time.toString();
                            }
                            
                            // Smooth interpolation
                            const newX = currentX + (targetX - currentX) * 0.03;
                            const newY = currentY + (targetY - currentY) * 0.03;
                            core.dataset.currentX = newX.toString();
                            core.dataset.currentY = newY.toString();
                            
                            const time = glowData.time * speed;
                            
                            // Add slight drift
                            const coreX = newX + Math.sin(time + phase) * 3;
                            const coreY = newY + Math.cos(time * 0.7 + phase) * 3;
                            
                            const coreScale = 1 + Math.sin(time + phase) * 0.15;
                            const coreBrightness = 0.8 + Math.sin(time * 1.5 + phase) * 0.2;
                            
                            core.style.transform = `
                                translate(-50%, -50%) 
                                translate(${coreX}px, ${coreY}px) 
                                scale(${coreScale})
                            `;
                            core.style.opacity = coreBrightness;
                        });
                    }
                });

                if (hasActiveGlows || this.activeGlows.size > 0) {
                    this.frameId = requestAnimationFrame(() => this.animate());
                } else {
                    this.frameId = null;
                }
            }

            endGlow(element) {
                const glowData = this.activeGlows.get(element);
                if (!glowData) return;

                if (glowData.fadeTimeout) {
                    clearTimeout(glowData.fadeTimeout);
                }

                glowData.active = false;
                glowData.wrapper.style.opacity = '0';
                glowData.wrapper.style.transition = 'opacity 0.4s ease-out';

                glowData.fadeTimeout = setTimeout(() => {
                    if (glowData.wrapper && glowData.wrapper.parentNode) {
                        glowData.wrapper.parentNode.removeChild(glowData.wrapper);
                    }
                    this.activeGlows.delete(element);
                    
                    if (this.activeGlows.size === 0 && this.frameId) {
                        cancelAnimationFrame(this.frameId);
                        this.frameId = null;
                    }
                }, 400);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const effect = new GlowEffect();
            
            // Debug: Check how many hoverglow elements exist
            const hoverElements = document.querySelectorAll('.hoverglow');
            console.log(`Found ${hoverElements.length} hoverglow elements`);
            
            // Ensure all hoverglow elements are properly styled
            hoverElements.forEach(element => {
                // Make sure the element is interactive
                const computedStyle = window.getComputedStyle(element);
                if (computedStyle.pointerEvents === 'none') {
                    element.style.pointerEvents = 'auto';
                }
            });
        });
    </script>
</body>
</html>